package xmlDigisign

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/base64"
	"encoding/xml"
)

// signedMessage : Message xml without signature tag
// signatureString : xml for signature generated by SignXML
// msgModel : Struct in which your message is going to marshal or un marshal
// will return error if there is signature missmatch
func (v *xmlSignature) VerifyXMLSignature(signedMessage, signatureString string, msgModel interface{}) error {
	signedMessage, err := formatXML(signedMessage, msgModel)
	// Canonicalize the signed XML message
	signedMessage = CanonicalizeXML(signedMessage)

	signModel := Signature{}
	xml.Unmarshal([]byte(signatureString), &signModel)

	// Compute the digest of the canonical XML data
	digest := sha256.Sum256([]byte(signedMessage))

	// Decode the signature value from base64
	signatureBytes, err := base64.StdEncoding.DecodeString(signModel.SignatureValue)
	if err != nil {
		return err
	}

	// Verify the signature using the public key
	err = rsa.VerifyPKCS1v15(v.certificate.PublicKey.(*rsa.PublicKey), crypto.SHA256, digest[:], signatureBytes)
	if err != nil {
		return err
	}

	return nil
}
